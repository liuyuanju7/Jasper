## Redis 

> Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库
>
> 中文文档地址：https://www.redis.com.cn

### Redis特点

#### 1.速度快

​		Redis将所有数据集存储在内存中，这就是它非常快的原因；Redis支持Pipelining命令，可一次发送多条命令来提高吞吐率，减少通信延迟；

#### 2.持久化

​		可以将内存数据保存在磁盘中，重启后可以再次加载使用

- **RDB快照**

  在默认情况下，Redis将内存数据库快照保存到`dump.rdb`的二进制文件中。也可以设置“在n秒内数据集至少有n个改动时”自动保存一次数据集

  ```shell
  save 60 1000  // 60秒内有1000个键被改动时，自动保存一次数据集
  ```

  也可以在客户端手动执行命令，生成RDB快照，并覆盖原有的rdb快照文件

  - `save` -- 同步命令
  - `bgsave` -- 异步命令 redis主进程fork一个子进程专门用来生成rdb二进制文件

- **AOF** **(append only file)**

  快照的方式并不是非常稳定，当redis因故障停机时，那么服务器将丢失最近写入且未保存到快照的数据，于是redis增加了另一种方式：`AOF`持久化，将修改的每一条**指令**记录进`appendonly.aof`文件中； 

  修改配置文件`appendonly yes`打开aof功能，打开后每执行一个改变数据集的命令时，这个命令就会**追加**到aof文件末尾，当redis重启时，就会重新执行aof中的**命令**重建数据集

  ```shell
  appendfsync always：每次有新命令追加到aof文件时就执行一个持久化，非常慢但是安全
  appendfsync everysec：每秒执行一次持久化，足够快（和使用rdb持久化差不多）并且在故障时只会丢失1秒钟的数据  -- 默认
  appendfsync no：从不持久化，将数据交给操作系统来处理。redis处理命令速度加快但是不安全。
  ```

  - AOF重写

    aof文件里可能有太多“琐碎”指令，所以aof会定期根据内存的最新数据重新生成aof文件

    ```
    auto-aof-rewrite-min-size 64mb： aof文件至少要达到64m才会触发制动重写，文件太小恢复速度本来就很快，重写的意义不大
    
    auto-aof-rewrite-percentage 100：aof文件上一次重写后文件大小增长了100%则再次触发重写
    ```

- **RDB/AOF 对比**

  | 方式       | RDB        | AOF        |
  | ---------- | ---------- | ---------- |
  | 启动优先级 | 低         | 高         |
  | 体积       | 小         | 大         |
  | 恢复速度   | 快         | 慢         |
  | 数据看权限 | 容易丢数据 | 视策略而定 |

  redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof文件一般来说数据更安全一点

- **Redis4.0 混合持久化**

  单独的rdb恢复可能会丢失较多数据，单独的重放aof日志性能较慢；混合持久化：`RDB格式+AOF格式`组成`appendonly.aof`；即 **aof在重写**时，先将此刻之前的内存数据做rdb快照处理，并且将快照内容和 **增量**的aof修改内容数据的命令存在一起，都写入新的aof文件(写入完成后才重命名为appendonly.aof) 这样在重启时就先加载rdb文件，再增量重放aof日志，大幅提高数据恢复效率

#### 3.数据结构

​		Redis支持各种类型的数据结构，例如字符串，散列，集合，列表，带有范围查询的有序集

- 字符串 `string`

  ```lua
  SET key value
  GET key
  ```

- 哈希  `hash`

  Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。每个哈希键中可以存储多达40亿个字段值对

  ```lua
  HEXISTS key field  确定是否存在哈希字段。
  HGET key field 获取存储在指定键中的哈希字段的值
  HSET key field  设置哈希字段的字符串值
  HGETALL key  获取存储在指定键的散列中的所有字段和值
  ```

- 列表 `list`

  Redis列表是按插入顺序排序的字符串列表。可以在列表的头部（左边）或尾部（右边）添加元素

  ```lua
  LINDEX key index  通过索引从列表中获取元素
  LPOP key	删除和获取列表中的第一个元素
  LPUSH key value1 [value2]	将一个或多个值添加到列表中
  ```

- 集合 `set`

  Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中没有重复的数据。在Redis中，添加、删除和查找的时间复杂都是O(1)（不管Set中包含多少元素）

  ```lua
  SADD key member1 [member2]	将一个或多个成员添加到集合中
  SPOP key	移除并返回集合中的一个随机元素
  SDIFF key1 [key2]	返回给定所有集合的差集
  SINTER key1 [key2]	返回集合交集
  SCARD key	获取集合中的成员数量
  ```

- 有序集合  `sorted set`

  Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)

  ```lua
  ZADD key score1 member1 [score2 member2]	向有序集合添加一个或多个成员，或者更新已存在成员的分数
  ZCARD key	获取有序集合的成员数
  ```

  

#### 4.原子操作

​		 Redis的单个操作都是原子性的；多个操作也支持事务即原子性，通过`MULTI`和`EXEC`指令包起来

- **原子性原理**

  - Redis是`单进程单线程`的网络模型，用的是`epoll(多路复用)`网络模型，都是单线程异步非阻塞处理网络请求
  - Redis单线程小狐狸所有的客户端连接请求，命令读写请求（rdb、aof等操作是fork子进程处理，不影响主进程处理客户端命令）
  - Redis提供的所有API操作，对于服务端都是one by one执行的，一个接着一个执行，不存在并发执行的情况
  - 高并发错误读写 ？

- **Redis 事务**

  - 事务中的所有命令都作为一个隔离操作顺序执行。您无法在执行Redis事务期间由另一个客户端发出请求
  - Redis事务是原子的。原子意味着要么执行所有命令，要么任何命令都不执行

  ```
  MULTI 标记一个事务块的开始
  EXEC 执行所有事务块内的命令
  DISCARD 取消事务，放弃执行事务块内的所有命令
  WATCH key [key …] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
  UNWATCH 取消 WATCH 命令对所有 key 的监视
  ```

- **Redis流水线**

  Redis是一个支持请求/响应协议的TCP服务器。在Redis中，请求分两步完成：

  - 客户端通常以阻塞方式向服务器发送命令。
  - 服务器处理该命令并将响应发送回客户端。

  `流水线操作`有助于客户端向服务器发送多个请求，而无需等待回复，最后只需一步即可读取回复;由于多个命令同时执行，它极大地提高了协议性能

#### 5.主从复制

​		Redis主从同步。数据可以从主服务器向任意数量的从服务器上同步；从服务器也可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。

> Tip: Redis 不支持 主主复制，被互相设置为主服务器的两个redis实例，只会持续的占用大量处理器资源，并且不断尝试与对方通信，根据客户端连接的服务器不同可能的到不一致的数据或者得不到数据

​		Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步;

- **全量同步**

  全量复制一般发生在Slave初始化阶段，这是Slave需要将master上的所有数据复制一份。

  1. 从服务连接主服务器发送 `SYNC`命令
  2. 服务器接收到 `SYNC` 命名后，开始执行`BGSAVE`命令生成RDB文件并使用`缓冲区`记录此后执行的所有`写命令`
  3. 主服务器`BGSAVE`执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令
  4. 从服务器收到快照文件后`丢弃所有旧数据`(如果有的话)，开始载入收到的快照；
  5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；
  6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令

- **增量同步**

  增量复制是指Slave初始化后，开始正常工作时，主服务器发生的写操作持续同步到从服务器，从服务器接受并执行收到的写命令的过程

  > Tip: 当多个Slave同时连接主服务器时，同步多个从服务器所占用的带宽可能会使得其他命令请求难以传递给主服务器，甚至IO剧增宕机； 为了缓解这个问题，可以创建一个由主从节点组成的中间层来分担主服务器的复制工作

- **哨兵模式**

  能够后台监控主机是否故障，如果故障了根据投票数自动将从酷转换为主库，通过定时任务获取最新的拓扑结构、交换主节点的状态、心跳检测

#### 6.分片/分区

​		分区用于将Redis数据拆分为多个Redis实例，以便每个实例仅包含一部分密钥。通常用于大型数据库

- **分区类型**

  - 范围分区

    范围分区是执行分区的最简单方法之一。它通过将对象的范围映射到特定的Redis实例来完成，比如3000个用户id 0到1000的用户进入R0， id 1000-2000的进入实例R1，2000-3000进入R3……

  - 哈希分区

    散列分区是Range分区的替代方法。在散列分区中，散列函数用于将密钥转换为数字，然后将数据存储在不同的Redis实例中

- **分区的优点**

  - 分区有助于使用多台计算机的集体内存，如果不进行分区则只能使用单台计算机可以支持的有限内存量
  - 分区还用于将计算能力扩展到多个核心和多个计算机，以及网络带宽扩展到多个计算机和网络适配器

- **分区的缺点**

  - 分区通常不支持具有多个键的操作。例如，如果两个集合存储在映射到不同Redis实例的键中，则无法执行它们之间的交集
  - 分区不支持具有多个密钥的事务
  - 分区粒度是关键，因此不可能使用单个巨大的密钥（如非常大的有序集）对数据集进行分片
  - 使用分区时，数据处理更复杂，例如，您必须处理多个RDB / AOF文件
  - 添加和删除容量可能很复杂

#### 7.Redis与其他key-value存储有什么不同？

- Redis是键值数据库中不同的演化路径，其中值可以包含更复杂的数据类型，并在这些数据类型上定义原子操作
- Redis数据类型与基本数据结构密切相关，并且无需额外的抽象层即可向程序员公开
- Redis是一个内存但持久的磁盘数据库，因此它代表了一种不同的折衷方案，其中通过不能大于内存的数据集的限制实现了非常高的写入和读取速度
- 内存数据库的另一个优点是，与磁盘上的相同数据结构相比，复杂数据结构的内存表示更易于操作
- 两种磁盘存储格式（RDB和AOF）不需要适合随机访问，因此它们非常紧凑，并且始终以仅附加方式生成

